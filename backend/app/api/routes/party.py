from fastapi import APIRouter, HTTPException, status
from app.db.supabase import supabase
from app.utils.email import send_match_email, send_host_email

from app.schemas.party import (
    PartyCreate,
    PartyResponse,
    PartyCreatedResponse,
    PartyAdminAction,
    PartyUpdate,
)
from app.utils.matching import generate_matches
from app.utils.email import send_match_email

router = APIRouter(prefix="/api/party", tags=["Party"])


@router.post("", response_model=PartyCreatedResponse, status_code=status.HTTP_201_CREATED)
def create_party(party: PartyCreate):
    """Create a new Secret Santa party."""
    
    # Prepare data for insertion (passcode is auto-generated by Supabase)
    party_data = {
        "id": party.id,
        "name": party.name,
        "description": party.description,
        "budget": party.budget,
        "currency": party.currency,
        "event_date": str(party.event_date),
        "event_time": str(party.event_time),
        "organizer_name": party.organizer_name,
        "organizer_email": party.organizer_email,
        "status": True,  # New parties are always OPEN
    }
    
    # Insert party
    response = supabase.table("parties").insert(party_data).execute()
    
    if not response.data:
        raise HTTPException(status_code=500, detail="Failed to create party")
    
    created_party = response.data[0]
    
    
    # -----------------------------------------------------------
    #  SEND HOST EMAIL (THIS IS THE CORRECT PLACE)
    # -----------------------------------------------------------
    room_link = f"https://dhrvm.github.io/SecretSanta/#/party/{created_party['id']}"
    
    send_host_email(
        host={
            "name": created_party["organizer_name"],
            "email": created_party["organizer_email"],
        },
        party_details={
            "name": created_party["name"],
            "event_date": created_party["event_date"],
            "event_time": created_party["event_time"],
            "budget": created_party["budget"],
            "currency": created_party["currency"],
        },
        room_code=created_party["passcode"],
        room_link=room_link
    )
    # -----------------------------------------------------------
    

    # If organizer wants to participate, add them as first participant
    if party.participate:
        participant_data = {
            "party_id": party.id,
            "name": party.organizer_name,
            "email": party.organizer_email,
        }
        supabase.table("participants").insert(participant_data).execute()
    
    return PartyCreatedResponse(
        id=created_party["id"],
        passcode=created_party["passcode"],
        name=created_party["name"],
    )



@router.get("/{party_id}", response_model=PartyResponse)
def get_party(party_id: str):
    """Get party details by ID."""
    
    response = supabase.table("parties").select("*").eq("id", party_id).execute()
    
    if not response.data:
        raise HTTPException(status_code=404, detail="Party not found")
    
    return response.data[0]


@router.patch("/{party_id}", response_model=PartyResponse)
def update_party(party_id: str, update: PartyUpdate):
    """Update party details. Requires master passcode."""
    
    # Verify passcode and get party
    party_response = supabase.table("parties").select("passcode").eq("id", party_id).execute()
    
    if not party_response.data:
        raise HTTPException(status_code=404, detail="Party not found")
    
    if party_response.data[0]["passcode"] != update.passcode:
        raise HTTPException(status_code=403, detail="Invalid passcode")
    
    # Prepare data
    data_to_update = {}
    if update.name:
        data_to_update["name"] = update.name
    if update.description:
        data_to_update["description"] = update.description
    if update.budget is not None:
        data_to_update["budget"] = update.budget
    if update.event_date:
        data_to_update["event_date"] = str(update.event_date)
    if update.event_time:
        data_to_update["event_time"] = str(update.event_time)
        
    if not data_to_update:
        raise HTTPException(status_code=400, detail="No data to update")
        
    # Perform update
    response = supabase.table("parties").update(data_to_update).eq("id", party_id).execute()
    
    if not response.data:
        raise HTTPException(status_code=500, detail="Failed to update party")
        
    return response.data[0]


@router.delete("/{party_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_party(party_id: str, auth: PartyAdminAction):
    """Delete a party. Requires master passcode."""
    
    # Verify passcode
    party_response = supabase.table("parties").select("passcode").eq("id", party_id).execute()
    
    if not party_response.data:
        raise HTTPException(status_code=404, detail="Party not found")
    
    if party_response.data[0]["passcode"] != auth.passcode:
        raise HTTPException(status_code=403, detail="Invalid passcode")
    
    # Delete party (cascade will delete participants)
    supabase.table("parties").delete().eq("id", party_id).execute()
    
    return None


@router.post("/{party_id}/lock")
def lock_party_and_match(party_id: str, auth: PartyAdminAction):
    """Lock the party and trigger matching. Requires master passcode."""
    
    # Verify passcode and get party
    party_response = supabase.table("parties").select("*").eq("id", party_id).execute()
    
    if not party_response.data:
        raise HTTPException(status_code=404, detail="Party not found")
    
    party = party_response.data[0]
    
    if party["passcode"] != auth.passcode:
        raise HTTPException(status_code=403, detail="Invalid passcode")
    
    if not party["status"]:  # Already locked
        raise HTTPException(status_code=400, detail="Party is already locked")
    
    # Get participants
    participants_response = supabase.table("participants").select("*").eq("party_id", party_id).execute()
    participants = participants_response.data
    
    if len(participants) < 2:
        raise HTTPException(status_code=400, detail="Need at least 2 participants to start matching")
    
    # 1. Generate Matches
    try:
        updates = generate_matches(participants)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Matching failed: {str(e)}")
    
    # 2. Update DB
    for update in updates:
        supabase.table("participants").update({"giftee_id": update["giftee_id"]}).eq("id", update["id"]).execute()
        
    # 3. Send Emails
    name_map = {p['id']: p['name'] for p in participants}
    email_map = {p['id']: p['email'] for p in participants}
    
    for p in participants:
        match_entry = next(u for u in updates if u['id'] == p['id'])
        giftee_name = name_map[match_entry['giftee_id']]
        giftee_email = email_map[match_entry['giftee_id']]
        send_match_email(p, giftee_name, giftee_email, party)
    
    # Lock the party
    supabase.table("parties").update({"status": False}).eq("id", party_id).execute()
    
    return {"message": "Matching complete! Emails have been sent."}


@router.post("/{party_id}/resend")
def resend_all_emails(party_id: str, auth: PartyAdminAction):
    """Resend all match emails. Requires master passcode."""
    
    # Verify passcode and get party
    party_response = supabase.table("parties").select("*").eq("id", party_id).execute()
    
    if not party_response.data:
        raise HTTPException(status_code=404, detail="Party not found")
    
    party = party_response.data[0]
    
    if party["passcode"] != auth.passcode:
        raise HTTPException(status_code=403, detail="Invalid passcode")
    
    if party["status"]:  # Party is still open
        raise HTTPException(status_code=400, detail="Matching has not started yet.")
    
    # Get participants
    participants = supabase.table("participants").select("*").eq("party_id", party_id).execute().data
    
    if not participants:
        return {"message": "No participants found."}

    # Map names
    name_map = {p['id']: p['name'] for p in participants}
    
    count = 0
    for p in participants:
        if p.get('giftee_id'):
            giftee_name = name_map.get(p['giftee_id'], "Unknown")
            if send_match_email(p, giftee_name, party):
                count += 1
                
    return {"message": f"Resent {count} emails."}
